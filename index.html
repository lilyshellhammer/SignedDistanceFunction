<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
    <meta charset="utf-8">
    <title>Signed Distance Function Test</title>
</head>

<body>
    <div id="app">
        <div class="container">
            <input id="input" type="file" v-on:change="input_change()"/>
            <input v-model="tileDim" placeholder="50"> 
            <br>
            {{ tileDim }}



        </div>
    </div>
</body>
<canvas id="canvas"></canvas>
<script src="vue.min.js"></script>
<script>
    new Vue({
        el: '#app',
        data() {
            return {
                w: "",
                h: "",
                c: "",
                img: "",
                ctx: "",
                input: "",
                reader: "",
                img: "",
                imgW: "", //px
                imgH: "", //px
                imgData: "",
                tileDim: "", //tile dimensions px
                tileCountX: "", //how many tiles we can fit
                tileCountY: "",
                offset: 1.1
            }
        },
        beforeMount() {
            // start with canvas
            c = document.getElementById("canvas")
            // get h and width, set cavas to that size
            w = innerWidth
            h = innerHeight
            c.width = w
            c.height = h
            // get context, important for putting images back
            ctx = c.getContext("2d")
            input = document.getElementById("input")
            reader = new FileReader()
            img = new Image()
        },
        methods: {
            //read file input
            input_change: function() {
                reader.readAsDataURL(input.files[0]);
                reader.onload = function() {
                    img.src = reader.result;
                    img.onload = function() {
                        //start
                        init();
                        var tiles = getTiles();
                        drawTiles(tiles);
                    }
                }
            },

            //function which finds h w and checks how many tiles
            init: function() {
                imgW = img.width;
                imgH = img.height;
                //check how many full tiles we can fit
                //right and bottom sides of the image will get cropped
                tileCountX = ~~(imgW / tileDim);
                tileCountY = ~~(imgH / tileDim);

                ctx.drawImage(img, 0, 0);
                imgData = ctx.getImageData(0, 0, imgW, imgH).data;
                ctx.clearRect(0, 0, w, h);
            },

            //get imgdata index from img px positions
            indexX: function(x) {
                var i = x * 4;
                if (i > imgData.length) console.warn("X out of bounds");
                return i;
            },

            indexY: function(y) {
                var i = imgW * 4 * y;
                if (i > imgData.length) console.warn("Y out of bounds");
                return i;
            },

            getIndex: function(x, y) {
                var i = indexX(x) + indexY(y);
                if (i > imgData.length) console.warn("XY out of bounds");
                return i;
            },

            //get a tile of size tileDim*tileDim from position xy
            getTile: function(x, y) {
                var tile = [];
                //loop over rows
                for (var i = 0; i < tileDim; i++) {
                    //slice original image from x to x + tileDim, concat
                    tile.push(...imgData.slice(getIndex(x, y + i), getIndex(x + tileDim, y + i)));
                }
                //convert back to typed array and to imgdata object
                tile = new ImageData(new Uint8ClampedArray(tile), tileDim, tileDim);
                //save original position
                tile.x = x;
                tile.y = y;
                return tile;
            },
            blur: function(tile) {
                var pix = tile.data;
                var rgb = {
                    r: 102,
                    g: 102,
                    b: 102
                }
                // Loop over each pixel and invert the color.
                var count = 0

                for (i = 0, n = pix.length; i < n; i += 4) {
                    count++
                    rgb.r += pix[i] // red
                    rgb.g += pix[i + 1] // green
                    rgb.b += pix[i + 2] // blue
                    // i+3 is alpha (the fourth element)
                }
                // floor the average values to give correct rgb values (ie: round number values)
                rgb.r = Math.floor(rgb.r / count);
                rgb.g = Math.floor(rgb.g / count);
                rgb.b = Math.floor(rgb.b / count);

                return rgb
            },
            //generate all tiles
            getTiles: function() {
                var tiles = [];
                for (var yi = 0; yi < tileCountY; yi++) {
                    for (var xi = 0; xi < tileCountX; xi++) {
                        tiles.push(getTile(xi * tileDim, yi * tileDim));
                    }
                }
                return tiles;
            },
            drawTiles: function(tiles) {
                colors = []
                numbers = []
                //tiles.forEach((d, i) => ctx.putImageData(d, d.x * offset, d.y * offset));
                tiles.forEach((d, i) => colors[i] = blur(d));
                // console.log(colors)
                for (var i = 0; i < tiles.length; i++) {
                    var fill = 'rgb(' + colors[i].r + ',' + colors[i].g + ',' + colors[i].b + ')'
                    ctx.fillStyle = fill;
                    if (fill == 'white')
                        numbers[i] = 0
                    else
                        numbers[i] = 1;
                    ctx.fillRect(tiles[i].x * offset, tiles[i].y * offset, tileDim, tileDim);
                }

                //            for(var i = 0; i < tiles.length; i++){
                //                document.write(numbers[i] + " ")
                //                if(i % (width/tileDim))
                //                    document.write("\n")
                //            }
                //            //more interesting effects are easy to do:
                // tiles.forEach((d,i) => ctx.putImageData(d, d.x * i * 0.01, d.y * i * 0.01));

                //for efficiency in animation etc tiles should be converted to image object
            }
        }
    })

</script>

<style>
    body {
        margin: 0;
    }

    canvas {
        display: block;
        width: 100%;
        height: 100%;
    }

    i {
        position: absolute;
        top: 0;
    }

    body {
        font-size: 12;
        font-family: sans-serif;
        background: rgb(239, 239, 239);
    }

    .container {
        position: relative;
        color: white;
    }

</style>

</html>
